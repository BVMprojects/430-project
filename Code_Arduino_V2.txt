#include <Wire.h>
#include <Servo.h>

// MPU6050 Registers and Constants
#define MPU6050_ADDR      0x68
#define ACCEL_CONFIG      0x1C
#define GYRO_CONFIG       0x1B
#define ACCEL_YOUT_H      0x3D
#define ACCEL_ZOUT_H      0x3F
#define GYRO_XOUT_H       0x43
#define PWR_MGMT_1        0x6B

// Complementary filter constants
#define Gyro_amount       0.996  // Complementary filter factor
const float Gyro_conversion = 6.07968E-5; // converts gyro reading to deg/loop
const float Degree_conversion = 57.2958;  // rad to deg conversion

// Global variables for MPU6050 data
int16_t AcY, AcZ, GyX;
float robot_angle = 0;
float Acc_angle = 0;
float GyX_offset = 0;
bool vertical = false;

// ESC control via Servo library
Servo esc;
const int escPin = 9; // PWM-capable pin connected to ESC

// Function prototypes
void writeToMPU(byte address, byte value);
void setupMPU6050();
void readMPU6050Data();
void calculateBalance();
float controlMotor(float angle_error);

// Writes a value to the MPU6050 register
void writeToMPU(byte address, byte value) {
  Wire.beginTransmission(MPU6050_ADDR);
  Wire.write(address);
  Wire.write(value);
  Wire.endTransmission();
}

// Setup function for MPU6050
void setupMPU6050() {
  Wire.begin();

  // Wake up MPU6050 and set ranges
  writeToMPU(PWR_MGMT_1, 0);  // Wake up
  writeToMPU(ACCEL_CONFIG, 0); // ±2g
  writeToMPU(GYRO_CONFIG, 0);  // ±250 deg/s
  delay(100);

  // Gyro calibration to find offset
  GyX_offset = 0;
  for (int i = 0; i < 1024; i++) {
    readMPU6050Data();
    GyX_offset += GyX;
    delay(5);
  }
  GyX_offset /= 1024;
}

// Reads ACCEL_Y, ACCEL_Z, GYRO_X from MPU6050
void readMPU6050Data() {
  Wire.beginTransmission(MPU6050_ADDR);
  Wire.write(ACCEL_YOUT_H);
  Wire.endTransmission(false);
  Wire.requestFrom(MPU6050_ADDR, 6, true);

  AcY = Wire.read() << 8 | Wire.read();
  AcZ = Wire.read() << 8 | Wire.read();
  GyX = Wire.read() << 8 | Wire.read();

  // Adjust gyro reading by offset
  GyX -= GyX_offset;
}

// Uses a complementary filter to combine accelerometer and gyro data to estimate the angle
void calculateBalance() {
  // Integrate gyro data (in degrees per loop)
  robot_angle += -GyX * Gyro_conversion;

  // Calculate angle from accelerometer data
  Acc_angle = atan2((float)AcY, -(float)AcZ) * Degree_conversion;

  // Complementary filter
  robot_angle = robot_angle * Gyro_amount + Acc_angle * (1.0 - Gyro_amount);
}

// Simple PID controller for angle error
float controlMotor(float angle_error) {
  static float previous_error = 0;
  float kp = 0.6;    // Proportional gain
  float kd = 0.05;   // Derivative gain

  float control_signal = kp * angle_error + kd * (angle_error - previous_error);
  previous_error = angle_error;

  // Limit range
  return constrain(control_signal, -12, 12);
}

void setup() {
  Serial.begin(115200);
  setupMPU6050();

  // Attach ESC
  esc.attach(escPin);
  
  // Initialize ESC at minimum throttle
  // Check ESC manual for exact initialization sequence
  esc.writeMicroseconds(1000); 
  delay(2000); // wait for ESC to initialize
}

void loop() {
  readMPU6050Data();
  calculateBalance();

  // If the tilt angle is large, stop output
  if (abs(robot_angle) > 10) {
    esc.writeMicroseconds(1500); // Assuming 1500 is neutral
    vertical = false;
    return;
  }

  vertical = true;

  // Calculate control signal (range -12 to 12)
  float motor_voltage = controlMotor(robot_angle);

  // Map -12..0..12 to 1000..1500..2000 microseconds
  // Adjust if your ESC requires different ranges
  int escPulse = map((int)motor_voltage, -12, 12, 1000, 2000);

  esc.writeMicroseconds(escPulse);
}
